%%==================================================
%% chapter03.tex for BIT Master Thesis
%% modified by 朱杰
%%==================================================
\chapter{基于稳定标签传播的非重叠社区发现算法}
由于社交网络“小世界”、“无标度”的特性以及目前社交网络普遍具有大规模的数据量，这对算法的时间复杂度提出了严格的要求。尽管至今已有为数不少的社区发现算法被学者们相继提出，但是这些算法大多是在社区识别的准确率上进行不断创新和优化，针对的多是中小规模的网络，面对大规模的社交网络数据这些算法往往需要巨大的时间开销。而本文在第一章节国内外研究现状中也已经提到，标签传播算法（LPA算法）\cite{Raghavan2007Near}是目前算法时间复杂度最低的社区发现算法，算法简单易理解且不需要任何先验信息，但是标签传播算法也有些许问题，例如稳定性差和算法无法收敛等。截至今天已经有不少学者在LPA算法的基础上进行了改进和创新，例如Leung等人\cite{Leung2009Towards}引入了启发式思想，在节点属性中加上了创新提出的hop score值，以此来提高算法效率及性能；文献\cite{He2014A}则是修改了LPA算法迭代的终止条件；LabelRank算法\cite{Xie2013LabelRank}创新的提出了标签概率矩阵，此法解决了LPA算法运行结果不稳定的问题。

标签传播算法是最早的基于标签传播思想的非重叠社区发现算法，本章节基于该算法进行研究和改进，将提出一种基于稳定标签传播的非重叠社区发现算法（Community Detection Algorithm Based on Stable Label Propagation）,下文简称CDABSLP。

本章将提出一种基于稳定标签传播的非重叠社区发现算法（Community Detection Algorithm Based on Stable Label Propagation）,下文简称 CDABSLP。CDABSLP 算法通过固定标签更新过程中节点的顺序，并且改进节点标签更新时标签选择的方法来提高 LPA 算法的性能。首先，算法计算网络中每个节点的影响值作为节点重要性的评判指标，并按照节点影响值降序排列作为标签更新过程中节点的顺序；然后，算法迭代的执行标签传播过程，直到检测到网络的社区结构。在每次标签传播过程中，CDABSLP 将节点影响值引入到标签计算公式中构造新的标签计算方法，计算邻接点中出现的每一个标签的重要性，更新节点标签。满足终止条件后，算法根据节点的标签将其划分到相应社区中，得到最终的社区划分结果。

本章接下来的内容组织结构上将先简单介绍下标签传播算法，然后详细介绍CDABSLP 算法的设计思路、核心思想和关键步骤等，最后在真实网络以及人工基准网络上的实验，并与其他基准算法进行对比实验，以此来分析算法的效果。

\section{标签传播算法缺陷分析}

2007年，Raghavan 等人\cite{Raghavan2007Near}首次将标签传播算法（LPA）应用到复杂网络社区发现中，LPA 算法的主要思想是利用网络的拓扑结构引导算法检测网络的社区结构。初始的时候，LPA 算法为每个节点分配一个唯一的各不相同的标签，表示开始的时候所有节点都各自组成一个社区。然后重复的进行标签更新过程，每执行一次，每个节点将自身的标签更新为它的邻居节点中最普遍存在的标签。如果多个标签在它的邻接点中出现的频次最高，那么 LPA 算法将随机的选择其中的一个标签赋给该节点。在这个重复的过程中，联系密集的节点逐渐将它们的标签更新为相同的标签，最后 LPA 算法根据节点的标签将其划分到相应社区中。

公式\ref{eqn:biaoqiangengxin}为 LPA 算法节点标签更新的公式。

\begin{equation}
  \label{eqn:biaoqiangengxin}
  c_i=\arg\max_l \left | \Gamma _i^l \right |
\end{equation}

其中$\Gamma _i^l$表示标签$l$的节点$i$的邻接集合。

LPA算法思想简单，容易理解，但是，在多次迭代后，算法并不能保证收敛。
在二分网络或近似二分网络中，当算法采用同步标签更新策略时，每个节点根据
其邻接点在上一次更新后得到的标签计算它本身新的标签，此时可能出现标签震
荡现象。如图\ref{fig:fig3-1}所示，二分网络中节点的标签在“1”和“2”之间来回震荡，始终不能收敛。因此，Raghavan等人\cite{Raghavan2007Near}又提出了标签的异步更新方法，在第t次迭代过程中，节点根据它的邻接点在当次迭代过程中已经完成标签更新的节点的新标签和还未进行更新的节点在t-1次迭代后得到的标签计算该节点的新标签。通过这种方式能够防止标签震荡现象的发生。

\begin{figure}
 \centering
 \includegraphics[width=0.75\textwidth]{figures/fig3-1}
 \caption{二分网络中的标签震荡现象}\label{fig:fig3-1}
\end{figure}

标签传播算法的设计方法简单，容易被人理解接受，算法的执行过程如算法\ref{alg:LPA}
所示。
\begin{algorithm}[htb]  
  \caption{标签传播算法（LPA)}  
  \label{alg:LPA}  
  \begin{algorithmic}[1]  
    \Require  
      复杂网络 $G = (V, E)$，最大迭代次数 $maxRun$  
    \Ensure  
      社区划分结果;  
    \State  初始化，为网络中的每个节点分配一个各不相同的标签，$c_i(0)=i$；

            令迭代次数$t=0$；

    \State  标签传播迭代过程:

            （a）如果迭代次数 $t > maxRun$，标签传播迭代过程结束，转 Step3；否则继续算法；

            （b）随机排列网络中的节点，并将节点顺序存放在向量 X 中；

            （c）对于每个节点$v_i\in X$，更新$c_i(t)=f(c_{i1}(t), c_{i2}(t),..., c_{im}(t))$表示在当次更新过程中节点$v_{i1}, ..., v_{im}$的邻接点中标签已经更新的节点集，表示在当次更新过程中节点的邻接点中标签还未更新的节点集；

            这里的函数$f(x)$将返回集合中出现频次最高的标签；

            如果返回不止一个标签，那么就在其中随机选择一个；

            （d）如果所有节点的标签都不再改变，那么标签传播迭代过程停止，转Step3；

            否则，令$t = t+1$转到步骤（a）继续执行；

    \State 社区划分，将拥有相同标签的节点划分到同一个社区中，不同标签的种类就表示网络中社区的个数。
  \end{algorithmic}  
\end{algorithm} 

LPA 算法每次迭代过程中更新节点的顺序随机确定，并且当多个标签在其邻接点中出现次数最多时，标签的更新也是随机的，因此每次执行标签传播算法都可能得到不同的社区划分结果。在众多的社区划分结果中，很难确定哪一个结果是最优的划分。所以解决标签传播算法的稳定性问题是非常有必要的，而且也是非常重要的。

通过上面的分析，传统的异步标签传播算法对节点更新的顺序及标签选择方
法非常敏感，标签传播过程中的随机性不仅造成算法收敛速度的不同，甚至会影响最终的社区划分结果。因此，本章提出一种改进的标签传播算法，克服传统
标签传播算法的不足。

% \begin{algorithm}  
%   \caption{用归并排序求逆序数}  
%   \begin{algorithmic}[1] %每行显示行号  
%       \Require $Array$数组，$n$数组大小  
%       \Ensure 逆序数  
%       \Function {MergerSort}{$Array, left, right$}  
%           \State $result \gets 0$  
%           \If {$left < right$}  
%               \State $middle \gets (left + right) / 2$  
%               \State $result \gets result +$ \Call{MergerSort}{$Array, left, middle$}  
%               \State $result \gets result +$ \Call{MergerSort}{$Array, middle, right$}  
%               \State $result \gets result +$ \Call{Merger}{$Array,left,middle,right$}  
%           \EndIf  
%           \State \Return{$result$}  
%       \EndFunction  
%       \State  
%       \Function{Merger}{$Array, left, middle, right$}  
%           \State $i\gets left$  
%           \State $j\gets middle$  
%           \State $k\gets 0$  
%           \State $result \gets 0$  
%           \While{$i<middle$ \textbf{and} $j<right$}  
%               \If{$Array[i]<Array[j]$}  
%                   \State $B[k++]\gets Array[i++]$  
%               \Else  
%                   \State $B[k++] \gets Array[j++]$  
%                   \State $result \gets result + (middle - i)$  
%               \EndIf  
%           \EndWhile  
%           \While{$i<middle$}  
%               \State $B[k++] \gets Array[i++]$  
%           \EndWhile  
%           \While{$j<right$}  
%               \State $B[k++] \gets Array[j++]$  
%           \EndWhile  
%           \For{$i = 0 \to k-1$}  
%               \State $Array[left + i] \gets B[i]$  
%           \EndFor  
%           \State \Return{$result$}  
%       \EndFunction  
%   \end{algorithmic}  
% \end{algorithm}

\section{算法稳定性设计}
\subsection{节点影响值}
在第二章第一小节社交网络的统计特性中，很多计算节点重要性的方法被提出，比如度、聚集系数和介数等。度和聚集系数仅能够衡量网络局部的信息；介数能够反映整个网络的全局信息，但是由于介数的计算需要计算网络中所有的最短路径，因此它的时间复杂度很高。Kitsak 等人[?]提出复杂网络中 k-核值高的节点对整个网络的信息传播是非常重要的，其传播能力强。

k-核分解方法是将复杂网络分解成若干子结构，子结构中的每个节点在该子
结构中的度最小为 k。为 k-核中的每个节点 i 分配一个 k-核值，用 Ks(i)表示，该
值表明节点 i 属于 k-核，但是不属于(k+1)-核。k-核值的大小反应了节点在网络中
的中心性地位，k-核分解方法经常被用于识别网络中的中心和边缘节点。

k-核分解方法的具体步骤如下：首先不断的将网络中度为 1 的节点及与这些
节点相连的边移除，直到剩余网络中不再有度为 1 的节点为止，并将移除的节点
划分为 1-核子集，并设置这些节点的 k-核值为 1；使用同样的方法，递归的移除
剩余网络中度为 2 或小于 2 的节点及连接这些节点的边，直到剩余网络中不再有
度为 2 或小于 2 的节点为止，创建 2-核子集；分解过程继续执行，直到网络中所
有的节点都被划分到相应的 k-核子集中。k-核值大（或小）的节点子集位于网络
的中心（或边缘）位置。通过 k-核分解方法能够得到网络的层次结构，该结构类
似于一个洋葱，反应了网络中节点完整的层次结构。k-核分解方法能够在线性时
间内执行完成，时间复杂度为 $O(|E|)$，其中|E|是网络中边的数量。

k-核值大的节点表示它位于网络的核心位置，然而，在复杂网络中，有大量
节点拥有相同的 k-核值，因此，仅根据该指标对节点进行排序的效果并不好。通
常，在复杂网络中，一个节点如果和很多核心节点相连，那么该节点在网络中的
地位也是很重要的。受该思想的启发，本章提出一种同时考虑节点本身 k-核值和
其邻接点 k-核值共同影响的节点中心性衡量指标。节点 i 的影响值的计算如公式\ref{eqn:NI}所示。

\begin{equation}
  \label{eqn:NI}
  NI(i)=Ks(i)+\alpha \times \sum_{j \in \Gamma _i} \frac{Ks(j)}{d_j}
\end{equation}

其中，$\alpha$是调节参数，取值范围从 0 到 1，用来调节邻接点对节点影响值的
作用大小。将公式\ref{eqn:NI}计算得到的节点影响值作为衡量节点重要性的指标，按节
点影响值降序对节点进行排序作为节点更新的顺序。固定节点更新顺序能够使算
法更加稳定。 

\subsection{异步标签传播策略}

异步标签传播策略能够避免标签震荡现象，并且相对同步标签更新策略需要
更少的迭代次数，因此这里采用异步标签更新方法。然而由于节点并不是同时更
新的，因此节点更新的顺序对社区发现结果的稳定性及社区质量有很大的影响；
除此之外，标签传播过程中的标签选择策略也存在不稳定因素，当返回多个标签
同时被最大个数邻接点拥有时，LPA 算法随机的选择其中的一个标签作为该节点
的新标签，这也造成了 LPA 算法的不稳定性。而 下一章节要提到的COPRA 中也同样存在这些不稳
定因素。

在简单网络上分析传统标签传播算法的社区发现过程，如图\ref{fig:fig3-2}所示。在
该网络中有两个社区，分别是${v_1,v_2,v_3}$和${v_4,v_5,v_6}$。节点上的数字表示该节点
的社区标签，初始的时候各个节点的社区标签各不相同，如图\ref{fig:fig3-2}(a)所示。假设
经过几次标签传播之后，节点拥有相同的标签“2”，而节点 $v_4$、$v_5$和 $v_6$
的标签仍然各不相同，如图\ref{fig:fig3-2}(b)所示。如果首先更新节点 $v_4$
的标签，由于它的所有邻接点的标签都各不相同，随机选择标签“2”作为节点 $v_4$
的新标签，
更新结果如图\ref{fig:fig3-2}(c)所示；然后更新节点 $v_6$
的标签为标签“2”，此时节点 $v_5$
的两个邻接点的标签都为“2”，它也更新为标签“2”。这样更新后所有的节点都划分
到了同一个社区中，这样的社区划分结果没有意义。相反，在更新节点 $v_4$
的标签时，如果随机选择的更新标签是标签“6”，如图 \ref{fig:fig3-2}(d)所示；紧接着更新节点$v_5$
的标签，根据标签计算公式得到节点 $v_5$
的新标签为标签“6”；此时节点 $v_6$的
两个邻接点的标签都为“6”，它的标签保持不变。通过这样的标签更新顺序和标
签选择方式，能够得到正确的社区划分结果。

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/fig3-2}
  \caption{标签传播过程示意图}\label{fig:fig3-2}
\end{figure}

通过上面的分析，传统的异步标签传播算法对节点更新的顺序及标签选择方
法非常敏感，标签传播过程中的随机性不仅造成算法收敛速度的不同，甚至会影响最终的社区划分结果。因此，本章提出一种改进的标签传播算法，克服传统
标签传播算法的不足。

\subsection{节点更新顺序上的改进}
在CDABSLP算法中，仍采用异步更新策略来避免图\ref{fig:fig3-1}所示的标签震荡现象的出现。
但是，不确定的节点更新顺序导致算法的稳定性差，新算法中需要克服此问题。
在算法每次的更新过程中，先更新的节点的标签在整个标签传播过程中发挥的作
用比后更新的节点的标签的作用要大，这是因为后更新节点的新标签对已经更新
的节点的标签没有影响，最后一个更新的节点的新标签对其他所有节点的标签选
择都不会产生影响。因此，算法应该根据节点的重要性对节点进行排序，重要的
节点应该优先更新。 

上文已经提到了节点影响值，节点 i 的影响值的计算可参考公式\ref{eqn:NI}。每轮标签传播迭代的时候，将节点按照节点影响值降序排列加入队列，更新节点标签的顺序即是节点影响值得降序，如此一来就解决了节点更新顺序随机化带来的不稳定性的问题。
% k-核值大的节点表示它位于网络的核心位置，然而，在复杂网络中，有大量
% 节点拥有相同的 k-核值，因此，仅根据该指标对节点进行排序的效果并不好。通
% 常，在复杂网络中，一个节点如果和很多核心节点相连，那么该节点在网络中的
% 地位也是很重要的。受该思想的启发，本章提出一种同时考虑节点本身 k-核值和
% 其邻接点 k-核值共同影响的节点中心性衡量指标。节点 i 的影响值的计算如公式\ref{eqn:NI}所示。

% \begin{equation}
%   \label{eqn:NI}
%   NI(i)=Ks(i)+\alpha \times \sum_{j \in \Gamma _i} \frac{Ks(j)}{d_j}
% \end{equation}

% 其中，$\alpha$是调节参数，取值范围从 0 到 1，用来调节邻接点对节点影响值的
% 作用大小。将公式\ref{eqn:NI}计算得到的节点影响值作为衡量节点重要性的指标，按节
% 点影响值降序对节点进行排序作为节点更新的顺序。固定节点更新顺序能够使算
% 法更加稳定。 
\subsection{标签选择阶段的改进}
造成标签传播算法不稳定的另一个因素是标签选择的机制，当更新一个节点
的标签时，如果返回多个标签同时被最大个数的邻接点拥有时，传统的标签传播
算法会随机的从中选择一个标签赋给该节点，因此，算法迭代过程很难得到一个
稳定的收敛状态。为了提高算法的稳定性，当返回多个标签时，将节点影响值引
入到标签更新公式中，选择标签影响强度最大的标签赋给该节点。 

标签l对节点i的影响强度计算如公式\ref{eqn:LI}所示。

\begin{equation}
  \label{eqn:LI}
  NI(i,l)=\sum_{j \in \Gamma _i} \frac{NI(j)}{d_j}
\end{equation}

其中，$\Gamma _i$
表示节点i的邻接点中标签为l的节点集合。改进的节点标签更新公
式如公式\ref{eqn:ci}所示。

\begin{equation}
  \label{eqn:ci}
  c_i=\arg\max_{l \in lmax} LI(i,l)
\end{equation}

其中，$lmax $表示同时被最大个数邻接点拥有的标签集合。 
当传统标签传播算法的标签更新公式返回多个标签时，根据公式\ref{eqn:LI}计算这
些标签对该节点的影响强度，选择影响强度最大的标签赋给该节点。当标签影响
强度最大的标签仍有多个时，节点保留原有标签。 

\section{算法执行步骤}
CDABSLP算法的主要步骤包括初始化、迭代标签传播和社区划分，图\ref{fig:fig3-3}为
CDABSLP算法的流程图。

\begin{figure}
  \centering
  \includegraphics[width=1\textwidth]{figures/fig3-3}
  \caption{CDABSLP算法流程图}\label{fig:fig3-3}
 \end{figure}

通过一个简单的例子来展示 CDABSLP算法的执行过程，如图\ref{fig:fig3-4}所示，算法
中参数$\alpha =1$。图中每一个圆圈代表一个节点，节点间的连线代表节点间的边，
节点外的实数表示节点的影响值$ NI$。按节点影响值降序排列图中的节点$v_1-v_2-v_4-v_6-v_5$
（当节点影响值相同时，按节点的先后顺序排列），以该顺序作为
节点更新的顺序，标签更新过程如图\ref{fig:fig3-4}所示。

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/fig3-4}
  \caption{CDABSLP算法标签传播过程示意图}\label{fig:fig3-4}
 \end{figure}

 按照节点更新顺序，第一个更新节点$v_1$
的标签。首先为节点$v_1$计算一系列
的三元组$(l,|\Gamma _1^l|,LI(v_1,l))$，其中$ l $表示其邻接点中包含的标签，
$|\Gamma _1^l|$表示标签为
$l $的邻接点的个数，最后一项$LI(v_1,l)$表示标签对该节点的影响强度，该项是一个
可选项，当不能通过传统的标签选择策略得到一个确定的标签时，通过公式\ref{eqn:LI}
计算得到。如图\ref{fig:fig3-4}(a)所示，节点$ v_1
$有三个邻接点$ v_2$
、$v_3$和 $v_4$，并且它们的标签
各不相同，计算得到节点 $v_1$
对应的三元组集合为${(2, 1, 1.833), (3, 1, 1.667), (4, 1, 
1.667)}$。因此选择标签 2 作为节点 $v_1$
的新标签。 

接着更新节点 v3的标签。更新完节点 $v_1$的标签之后，如图\ref{fig:fig3-4}(a)右图所示，节点$ v_3$共有三个邻接点$ v_1$、$v_2$和$ v_6$，其中$ v_1$和$ v_2$的标签相同，均为标签 2，只有节点 $v_6$的标签不同。因此选择标签 2 作为节点 $v_3$的新标签，如图\ref{fig:fig3-4}(b)所示。接下来节点$ v_4$和$ v_6$标签的更新分别与节点$ v_1$和$ v_3$的情况相同，更新结果如图\ref{fig:fig3-4}(c)所示。

最后只有节点$ v_2$和$ v_5$没有更新，此时如图\ref{fig:fig3-4}(c)所示，节点 $v_2$和它的邻接点的标签都为标签 2，而节点 $v5$与它所有的邻接点的标签都为标签 5，因此节点$v_2$和$ v_5$的标签不需要改变。

通过执行 CDABSLP 算法，在该网络上仅需执行一次标签更新过程就得到了最
终稳定的社区划分结构，得到两个与真实情况一致的社区。由于算法的执行过程
中没有了随机因素的存在，因此算法的输出结果是确定的且优质的。 

\section{算法时间复杂度分析}
算法的时间复杂度分析如下，$|V|$表示网络中节点的个数，$|E|$表示网
络中边的数目。 

（1）为每个节点初始化标签所用时间复杂度为 $O(|V|)$； 

（2）计算网络中所有节点的影响值的时间复杂度为 $O(|E|)$； 

（3）按节点影响值降序排列网络中所有节点所用时间复杂度为
$O(|V|log(|V|))$；

（4）每次标签传播过程分为两部分： 传统的标签计算过程：$O(|E|)$； 当传统标签计算过程返回多个标签时，利用公式\ref{eqn:LI}重新计算节点标签的过程：$O(|E|)$； 

（5）将相同标签的节点划分到一个社区的时间复杂度为 $O(|V|)$。 

标签传播过程是不断迭代执行的，因此整个算法的时间复杂度为
$2O(|V|)+(2t+1)O(|E|)+O(|V|log(|V|))$，$t $表示迭代次数，一般通过比较少的迭
代次数就能得到最后的结果。 


\section{验证实验}
本节为本章提出的基于稳定标签传播的非重叠社区发现算法CDABSLP算法进行实验验证。首先介绍实验的软硬件环境和采用的数据集，然后对算法的评价指标进行简单阐述，最后是相关对比实验的结果展示与分析,将CDABSLP
算法与传统 LPA、KBLPA\cite{邓观明2016基于混合的} 和 CNM 算法进行比较；将OCDABSLP与原 COPRA
算法进行比较。由于 LPA、KBLPA 和 COPRA 算法的不稳定性，分别执行这三
种算法 100 次，取结果的平均值作为最后的实验结果。通过算法得到结果的波动
范围比较算法的稳定性。 

\subsection{实验环境}
本文实现的CDABSLP算法所使用的机器配置如表\ref{tab:tab3-1}所示。CDABSLP算法使用Python语言编程实现，均基于Python的复杂网络相关软件包Networkx，使用Anaconda来对软件包进行管理和部署，具体配置如表\ref{tab:tab3-2}所示。

\begin{table}
  \centering
  \caption{计算机硬件配置} \label{tab:tab3-1}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}cccc}
  \toprule
    处理器			&2.2GHz 双核 Intel Core i7 \\
    内存容量			&8 GB 1600 MHz DDR3 \\
    硬盘容量			&128GB 固态硬盘 \\
  \bottomrule
  \end{tabular*}
\end{table}

\begin{table}
  \centering
  \caption{计算机软件配置} \label{tab:tab3-2}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}cccc}
  \toprule
    操作系统			&macOS Sierra 10.12.6\\
    Anaconda版本  &conda 4.3.30 \\
    Networkx版本	&2.1 \\
    Python版本    &2.7.14\\
    Matplotlib版本  &2.0.2\\
    Numpy版本     &1.13.1\\
  \bottomrule
  \end{tabular*}
\end{table}

\subsection{数据集}
选用5个不同的真实数据集和LFR基准网络人工生成数据集进行实验验证本章所提算法的有效性。 

（1）真实数据集

在5个常用的真实网络数据集上进行实验验证本章算法的有效性，这5个真
实网络数据集包括Karate、Dolphins 和 Football 等，各个数据集的详细信息如表\ref{tab:tab3-3}所示；

R1:Karate是 Zachary 空手道俱乐部成员关系网络，网络中的所有节点对应各个成员，边表示两个端点对应的成员是好朋友。网络包含 34 个节点，78 条边和两个社区。 

R2:Dolphins是 Lusseau 等人对栖息在新西兰 Doubtful Sound 峡湾的一
个宽吻海豚群体进行长达 7 年的观察所构造出的海豚关系网，该群体包含 2 个家族共 62 只宽吻海豚。由这个群里的所有成员及它们间的接触关系构成一个包含
62 个节点，159 条边和两个社区的网络。

R3:Polbooks是从 Amazon 的图书销售记录抽象得到的网络数据集，
分析了 105 本与美国政治相关的书和它们的 441 条共同销售关系，依据亚马逊上
对图书的观点和评价情况，将这些书分为“自由派”、“中间派”和“保守派”三
个类。因此，此数据集包含 105 个节点，441 条边和三个社区。

R4:Football是分析美国高校橄榄球比赛对阵表得到的数据集。共有 115
所高校派出代表队参赛，共进行了 616 场比赛，按各代表队地区的不同将这个包
含 115 个节点 616 条边的网络分为 12 个社区。 

R5:Email是由 Guimer 等人收集公布的，包含位于西班牙加泰罗尼亚
自治区的罗维拉-威尔吉利大学（简称 URV）的教师和研究生之间的邮件往来关
系。两个用户或者说两个邮箱地址如果互相发送过邮件，就构成一条边。网络包
含 1133 个节点和 5451 条边。

\begin{table}
  \centering
  \caption{真实网络数据集} \label{tab:tab3-3}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}cccc}
  \toprule
    数据集名称		&节点数   &边数   &社区数\\
  \midrule
    Karate  &34 &78 &2\\
    Dolphins	&62 &159  &2\\
    Polbooks  &105  &441  &3\\
    Football  &115  &616  &12\\
    Email     &1133 &5451 \\
  \bottomrule
  \end{tabular*}
\end{table}

（2）LFR人工基准网络

LFR基准网络是目前在社区发现领域使用最多的人工数据集之一。通
过调整网络生成参数可以产生用户需要的不同的人工数据集，LFR 基准网络的主
要生成参数及其含义如表\ref{tab:tab3-4}所示。

\begin{table}
  \centering
  \caption{LFR基准网络生成参数及其含义} \label{tab:tab3-4}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}cccc}
  \toprule
    参数		&含义\\
  \midrule
    N  &节点数\\
    avgk	&节点平均度\\ 
    maxk  &节点最大度\\
    mu  &网络拓扑结构混合参数\\
    minc  &最小社区规模\\
    maxc  &最大社区规模 \\
    on    &重叠节点个数\\
    om    &重叠节点可属于的社区个数\\
  \bottomrule
  \end{tabular*}
\end{table}

在 LFR 模型众多的生成参数中，混合参数$ mu \in [0,1]$是非常重要的一个参数，
mu 越小，说明连接社区之间的边越少，社区之间越“分离”，社区划分的难度随
着 mu 的增长而增大。on 和 om 两个参数用于生成具有重叠社区的数据集，生成
具有非重叠社区结构的数据集时，只需将 on 设置为 0，om 设置为 1 即可。 
生成六组具有非重叠社区结构的 LFR 基准网络数据集，所有的网络共享的
相同参数是 maxk = 50、on = 0 和 om = 1。每组包含九个 mu 值不同的数据集，分
别为 0.1 到 0.9，每组中的九个数据集共享参数 N、avgk、minc 和 maxc。其他参
数都取默认值。表\ref{tab:tab3-5}展示了这六组网络详细的生成参数情况。 

\begin{table}
  \centering
  \caption{六组LFR基准网络生成参数} \label{tab:tab3-5}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}ccccccc}
  \toprule
    编号		&N  &avgk &maxk &minc &maxc &mu\\
  \midrule
    S1  &100000  &100 &5000 &100 &5000 &$0.1\sim 0.9$\\
    S2  &100000  &100 &5000 &200 &1000 &$0.1\sim 0.9$\\
    S3  &500000  &100 &5000 &100 &5000 &$0.1\sim 0.9$\\
    S4  &500000  &100 &5000 &200 &1000 &$0.1\sim 0.9$\\
    S5  &100000  &200 &5000 &100 &5000 &$0.1\sim 0.9$\\
    S6  &100000  &200 &5000 &200 &1000 &$0.1\sim 0.9$\\
  \bottomrule
  \end{tabular*}
\end{table}

\subsection{评价指标}
迄今为止，出现了各种各样的社区发现算法，如何评价不同的的发现算法的好坏是一个非常重要的问题。为此，学者们提出了多种社区结构评价指标用来评价网络社区划分质量，其中比较有代表性的有模块度、NMI等。下面介绍这些指标。

（1）模块度

模块度是目前学者们最常用和经典的网络社区结构评价指标，它最初是被Newman等人于2004年提出来的\cite{2002Community}。其通过比较现有网络和基准网络在相同社区划分下的连接密度差来衡量网络社区的优劣，其中基准网络是由原网络具有相同度序列的随机网络。模块度计算方式详见公式\ref{eqn:modular}。

\begin{equation}
  \label{eqn:modular}
  Q=\frac{1}{2m}\sum_{i,j}\left [ A_{ij}-\frac{k_ik_j}{2m} \right ]\delta (c_i, c_j)  
\end{equation}

其中，A 表示网络中的邻接矩阵， m 表示网络中边的总数，$k_i$和$k_j$表示节点 i 和 j 的度数，$c_i$和$c_j$表示节点 i 和 j 所属的社区。如果$i=j,\delta(c_i,c_j)=1$，反之$\delta(c_i,c_j)=0$

（2）NMI

随着在线社交网络的发展，人们发现在线社交网络的很多数据中存在着暗示各个节点的社区属性信息。例如，在人人网的学校信息便揭示了网络节点中属于同一学校的社区结构，Facebook中的兴趣信息同样表征了具有相同兴趣的虚拟用户群体。这些数据在为社区发现问题提供了丰富的信息的同时，也在一定程度上为虚拟社区结构优劣的评判提供了标准答案。针对这种预先拥有一定虚拟社区结构信息的情况下，Leon Danon等人[?]提出了Normalized Mutual Information（NMI）利用信息化熵来衡量算法划分的社区结构和预先已知的社区结构之间的差异。NMI是基于混合矩阵（Confusion Matrix）N来计算的数字指标。NMI计算方式详见公式\ref{eqn:nmi}。

\begin{equation}
  \label{eqn:nmi}
  NMI=\frac{ -2 \sum_{i,j} N_{ij}  ln{\frac{N_{ij}}{N_iN_j}} } {\sum_{i}N_iln{\frac{N_i}{n}}+\sum_{j}N_jln{\frac{N_j}{n}}}
\end{equation}

使用该数字指标，可以衡量划分出来的社区结构与已知的网络社区结构的差异程度值，该值越大，则表明获得的社区结构划分越好，当该值达到最大化值1时，说明算法发现的社区结构与已知社区结构完全已知，效果最好。

\begin{figure}
 \centering
 \includegraphics[width=0.75\textwidth]{figures/fig5-1}
 \caption{NMI网络示例图}\label{fig:fig5-1}
\end{figure}

下面以图\ref{fig:fig5-1}为例来说明计算NMI的过程。假设已知的最佳社区结构划分为集合{1，2，3，4}和{5，6，7，8}，相应的社区划分向量表示为a = (1,1,1,1,2,3,3,3,3)，再假设某算法获得的社区划分结构可以用向量表示为b = (3,3,3,3,2,1,1,1,1)来表示。根据已知的社区划分向量，可以构造混合矩阵\ref{eqn:n}。

\begin{equation}
  \label{eqn:n}
  N=\begin{bmatrix}
    0 & 0 &4 \\ 
    0 & 1 & 0\\ 
    4 & 0 & 0
    \end{bmatrix}
\end{equation}

根据上式计算可知，该划分的NMI值为1。

（3）PWF

成对 F-measure（Pairwise F-measure，PWF）是成对准确率（Pairwise Precision，
PWP）和成对召回率（Pairwise Recall，PWR）的调和，其计算如公式\ref{eqn:pwf}所示。

\begin{equation}
  \label{eqn:pwf}
  PWF=\frac{2\cdot PWP\cdot PWR}{PWP+PWR}
\end{equation}

成对准确率（PWP）和成对召回率（PWR）的计算公式分别为公式\ref{eqn:pwp}和公
式\ref{eqn:pwr}。

\begin{equation}
  \label{eqn:pwp}
  PWP=\frac{ \left | S \cap T \right |}{ \left | S \right |}
\end{equation}

\begin{equation}
  \label{eqn:pwr}
  PWP=\frac{ \left | S \cap T \right |}{ \left | T \right |}
\end{equation}

T 表示在真实的社区划分结果中，在同一个社区内的节点对集合；S 表示在
测试算法得到的社区划分结果中在同一个社区内的节点对集合；$\left | S \cap T \right |$ 表示在真实
的社区划分结果和测试划分结果中都在同一个社区内的节点对集合。PWF 的取
值范围是 $0 \sim 1$，PWF 越大，说明社区划分的准确率越高。

\subsection{实验结果及分析}

(1)LFR基准网络上的实验

图\ref{fig:S1deNMIhePWF} $\sim$ \ref{fig:S6deNMIhePWF}分别是四种算法在六组非重叠 LFR 基准网络数据集
（S1$\sim$S6）上实验结果的 NMI 和 PWF 指标的对比图。横轴代表混合参数 mu，取
值从 0.1 到 0.9；左侧六幅图的纵轴代表社区划分结果的 NMI 值，右侧六幅图的
纵轴表示实验结果的 PWF 值。

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/S1deNMIhePWF}
  \caption{在S1网络上的实验结果的NMI和PWF比较}\label{fig:S1deNMIhePWF}

  \includegraphics[width=0.75\textwidth]{figures/S2deNMIhePWF}
  \caption{在S2网络上的实验结果的NMI和PWF比较}\label{fig:S2deNMIhePWF}

  \includegraphics[width=0.75\textwidth]{figures/S3deNMIhePWF}
  \caption{在S3网络上的实验结果的NMI和PWF比较}\label{fig:S3deNMIhePWF}

  \includegraphics[width=0.75\textwidth]{figures/S4deNMIhePWF}
  \caption{在S4网络上的实验结果的NMI和PWF比较}\label{fig:S4deNMIhePWF}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/S5deNMIhePWF}
  \caption{在S5网络上的实验结果的NMI和PWF比较}\label{fig:S5deNMIhePWF}

  \includegraphics[width=0.75\textwidth]{figures/S6deNMIhePWF}
  \caption{在S6网络上的实验结果的NMI和PWF比较}\label{fig:S6deNMIhePWF}
\end{figure}

图\ref{fig:S1deNMIhePWF} $\sim$ \ref{fig:S6deNMIhePWF}中的 12 幅图可以看出，随着 mu 值的增大，网络的结构越来越复杂，
社区结构越来越不明显，四种算法得到的社区划分结果都随之变差，尤其是当
mu 大于 0.5 时，NMI 和 PWF 指标下降的更快。但是，整体来看，CDABSLP 算法
的效果优于其他三种算法。虽然 CDABSLP 算法并不是在所有情况下都能得到最优
的结果，但是它得到的结果是稳定的并且比较好的。从对比图中还能看出 LPA
算法得到结果的 NMI 和 PWF 的波动都很大；KBLPA 算法得到的结果是比较稳
定的，但是该算法检测得到的社区结构比 LPA 和 CDABSLP 算法都要差一些。在
所有这些 LFR 网络上，CNM 算法并不能检测到最优的社区结构，而且它得到的
社区的数目通常都比真实情况少。 

（2）真实网络上的实验

在数据集中介绍的5个真实网络数据集经常出现在社区发现的文献中，使
用模块度 Q 和标准化互信息 NMI 作为前四个数据集上实验结果的评价指标，而
另外一个数据集上仅使用模块度 Q 作为评价指标。 
表\ref{tab:tab3-6}和表\ref{tab:tab3-7}给出了四种对比算法在5个真实网络数据集上的实验结果，
由于 R5 网络的真实社区结构未知，所以在表 3-8 中仅给出了前四个网络上
实验结果的 NMI 值。每个数据集上得到的最优的 Q 和 NMI 值用粗体表示，LPA
算法和 CDABSLP 算法得到结果的 Q 和 NMI 以平均值±最大偏差的形式表示。

\begin{table}
  \centering
  \caption{真实网络的模块度实验结果} \label{tab:tab3-6}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}ccccc}
  \toprule
    编号		&LPA  &KBLPA &CDABLPA &CNM\\
  \midrule
    R1  &$0.296 \pm 0.29$  &$0.073 \pm 0.23$ &0.423 &0.345\\
    R2  &$0.465 \pm 0.19$  &$0.489 \pm 0.12$ &0.521 &0.306\\
    R3  &$0.489 \pm 0.15$  &$0.449 \pm 0.09$ &0.497 &0.265\\
    R4  &$0.582 \pm 0.14$  &$0.573 \pm 0.09$ &0.582 &0.537\\
    R5  &$0.380 \pm 0.27$  &$0.183 \pm 0.34$ &0.427 &0.415\\
  \bottomrule
  \end{tabular*}
\end{table}

\begin{table}
  \centering
  \caption{真实网络的模NMI实验结果} \label{tab:tab3-7}
  \begin{tabular*}{0.9\textwidth}{@{\extracolsep{\fill}}ccccc}
  \toprule
    编号		&LPA  &KBLPA &CDABLPA &CNM\\
  \midrule
    R1  &$0.583 \pm 0.58$  &$0.173 \pm 0.53$ &1 &0.435\\
    R2  &$0.526 \pm 0.19$  &$0.471 \pm 0.22$ &0.622 &0.426\\
    R3  &$0.574 \pm 0.07$  &$0.524 \pm 0.09$ &0.656 &0.255\\
    R4  &$0.863 \pm 0.24$  &$0.849 \pm 0.14$ &0.878 &0.636\\
  \bottomrule
  \end{tabular*}
\end{table}

从表\ref{tab:tab3-6}和表\ref{tab:tab3-7}可以看出，
CDABSLP 算法得到社区结构的模块度 Q 比其他三种算法都高。同时，CDABSLP 算
法在前四个网络上得到的社区结构的 NMI 值也是最优的。KBLPA 算法的稳定性
优于 LPA 算法，但是 KBLPA 算法在几乎所有网络上得到社区结构的 Q 和 NMI
都没有 LPA 算法好。实验结果表明，CDABSLP 算法能够得到比其他三种算法更
好更稳定的社区检测结果。

% （3）不同规模网络的实验对比

% 待加入。。。

（3）可视化对比

将 CDABSLP 算法在 Dolphins 数据集上检测得到的社区结构和 Dolphins网络
真实的社区结构进行比较，如图\ref{fig:Dolphins}所示。

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/Dolphins}
  \caption{Dolphins 数据集的社区结构}\label{fig:Dolphins}
\end{figure}

图\ref{fig:Dolphins}(a)展示的是 Dolphins 网络真实的社区结构，节点不同的颜色表示不
同社区；图\ref{fig:Dolphins}(b)是 CDABSLP 在 Dolphins 网络上检测到的社区结构图。通过比
较这两幅图， CDABSLP 算法得到的结果中，节点 DN63 和 SN90 的划分与 Dolphins
真实的社区结构不同。从 Dolphins 网络的拓扑结构发现，节点 DN63 有两个邻接
点，它们分别属于两个不同的社区；节点 DN63 有五个邻接点， CDABSLP 算法将
DN63 划分到了它的多数邻接点所在的社区。Dolphins 网络的真实的社区结构的
模块度比 CDABSLP 算法得到的社区结构的模块度小，可以看出 CDABSLP 算法得到
的结果是合理的。

（4）参数选择实验

在 CDABSLP 算法中只有一个参数，即调节参数$\alpha$。为了分析参数对算法的影
响，设置不同的参数$\alpha$值，在人工网络数据集上运行 CDABSLP 算法，通过比较
结果的 NMI 分析参数对算法的影响。通过这种方法，能够发现参数$\alpha$取什么值
时能够得到最好的结果。

生成五个 LFR 基准数据集，参数 avgk 分别从 10 到 50，其他的生成参数相
同（N = 1000、maxk = 50、minc = 10、maxc = 50 和 mu = 0.1）。图\ref{fig:alpha}显示了
CDABSLP 算法在这些网络上的实验结果，横轴代表参数$\alpha$的不同取值，从 0 到 1，
纵轴代表 NMI 值。

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{figures/alpha}
  \caption{不同$\alpha$值对结果的影响}\label{fig:alpha}
\end{figure}

从图\ref{fig:alpha}中可以看出，参数$\alpha$取不同值的情况下，算法得到结果的 NMI 值
变化很大。但是，对于每个网络，都存在一个最优的$\alpha$值使得 CDABSLP 算法能够
得到 NMI 值最大的社区划分结果。此外，还能看出，在每个网络上得到的第一
个极大值基本就是该网络上的最优值。

% \subsection{实验总结}

% CDABSLP算法从两个方面改善 LPA 算法不稳定的问题：首先，计算
% 网络中每个节点的节点影响值并按节点影响值降序排列作为节点标签更新的顺
% 序，取代传统 LPA 算法中节点更新顺序随机确定的方法；其次，在每次标签更
% 新迭代过程中，当传统的标签计算方法返回多个标签时，提出一种新的标签计算
% 公式，计算返回标签的影响强度，在返回的多个标签中重新选择一个影响强度最
% 大的标签作为该节点的新标签，以此替代传统 LPA 算法中随机选择一个标签的
% 方法。CDABSLP算法既保持了传统 LPA 算法的优点，还解决了 LPA 算法不稳定
% 的问题，该算法能够得到稳定的社区结构。大量实验结果表明CDABSLP算法的性
% 能优于目前一些代表性的社区发现算法。 

\section{本章小结}
本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数本章小结内容凑字数
